# 作用域是什么
作用域是一套规则，用于确定在何处以及如何查找变量。

## 编译原理
- 分词/词法分析
  - 将字符串也就是我们的代码，分解成有意义的代码块
  - 这些代码块被称为**词法单元**
  - 例如``var z = 1;``
    - 词法单元有：var,a,=,2,;
  - 分词和词法分析之间是有区别的
    - 主要在于词法单元的识别是通过**有状态**还是**无状态**的方式进行。
    - 如果词法单元生成器在**判断a是一个独立的词法单元还是其他词法单元一部分的时候**，调用的是**有状态的解析规则**，那么这个过程就是词法分析
    - 上面提到的**有状态的解析规则**指的是**状态机**
    - **状态机**
      - 状态机不是机器设备，而是一个数学模型
      - 涉及到State 状态，Event 事件，Action 动作，Transition 转换
      - 上面这四大概念，在使用状态机思想来写程序时候经常用到
- 解析/语法分析
  - 将上面得到的词法单元流（数组）转换成一个代表了程序语法结构的树--抽象语法书AST
- 代码生成
  - 将AST转换成为可执行代码的过程
  - 就是转化为机器可以运行的指令  
**JavaScript的编译过程不是发生在构建的时候，而是在代码执行前很短的时间内完成。简单来说就是执行前要进行编译，然后就要执行。**

## 理解作用域
三个角色 
- 引擎
  - 从头到尾负责整个的编译执行过程
- 编译器
  - 负责语法分析及代码生成等
- 作用域
  - 负责收集维护变量
  - 并且有一套严格的规则，控制着权限

还是以``var z = 1;``开头理解js处理的过程 
引擎处理的时候分两步，
1.由编译器在编译的时候处理  
2.引擎在运行时处理  
- 遇到``var z``编译器会询问作用域，在同一作用域集合内是否存在这个变量
  - 如果存在，则忽略声明，继续进行编译
  - 否则会要求在当前作用域集合中声明一个新的变量，命名为``z``
- 接下来就是生成引擎运行时所需要的代码
  - 这些代码会处理``z = 1``这个赋值操作
- 引擎运行时会先询问作用域
  - 在当前作用域集合中是否存在``z``
    - 存在，引擎会使用这个变量
    - 不存在，引擎会继续查找（向上一级）
      - 如果最后找到了，会将1赋值给它
      - 否则会抛出异常  
**总结**：变量赋值的操作会执行两个步骤，首先，如果变量在当前作用域集合中不存在，就声明一个，否者跳过声明；然后在运行时引擎会在作用域集合中查找该变量，如果能找到就会对他赋值。

**关于引擎执行代码**
以上面的例子来说，引擎会做两个操作``LHS``、``RHS``。
- ``LHS``是赋值操作的左侧操作
  - 查找变量容器本身，操作的目标
- ``RHS``是赋值操作的右侧操作
  - 就是查找值，赋值的源头 
- 函数声明并不符合变量操作
  - 它是在编译阶段代码生成的同事处理声明和值的定义
  - 所有在引擎执行代码的时候，不会有线程专门的将函数值分配给函数名

### 例子
```
function foo(a){
  console.log(a)
}
foo(2)
```
整个过程：
引擎：作用域,我需要foo进行RHS引用，有吗  
作用域：有，编译器声明了它，是一个函数，给你  
引擎：执行foo  
引擎：作用域，我需要对这个函数形参a进行LHS，有吗  
作用域：有，编译器将他声明成了foo的形参  
引擎：把2赋值给a
引擎：作用域，我要为console做RHS，有吗  
作用域：有，是个内置对象  
引擎：看看里面是不是有log(..)，有，是一个函数
引擎：作用域，我需要对a进行RHS  
作用域：这个变量没有动过  
引擎：把a的值2传递进log(..)  

## 作用域嵌套
当一个块或者函数嵌套在另一个块或者函数中时。就会发生作用域嵌套。因此，在当前作用域找不到某个变量的时候，引擎就会依次的向外层查找，直到找到，或者到最外层为止（即全局作用域）。LHS和RHS都是在当前楼层查找，没有就会去上一层，以此类推，这就是**作用域链**。

## 异常
上面讲的都是理想状态，如果在变量没声明的情况下就调用，就会出问题。
```
function foo(a){
  console.log(a+b)
  b=a
}
foo(1)
```
第一次对b进行RHS的时候是无法找到变量的，引擎会抛出``referenceError``异常。  
如果是执行LHS的时候发现没有，就会在全局作用域中创建一个，并将其返回给引擎。前提是不在严格模式下。



# 词法作用域
词法作用域就是定义在词法阶段的作用域。就是由你在写代码时将变量和块作用域写在哪里来决定的。  
因此大部分情况下，词法分析器处理代码时会保持作用域不变。会有一些特殊的方法可以在词法解析器处理过后依然可以修改作用域。  
例如一个函数就是一个作用域，可以嵌套内层可以定义和外层相同的变量名。  
## 欺骗词法（不推荐使用）
### eval
这个方法可以接受一个字符串参数，并且将其视为就是写在这个位置的代码。也就是说里面涉及到有关作用域的操作，引擎会默认的按照以前的规则进行词法作用域查找。  
例如：
```
function foo(str,a){
  eval(str)
  console.log(a,b)
}
var b = 2
foo('var b = 6',1)
//1,6
```
上面代码在执行的时候会在foo作用域下声明一个变量b，这样外部的b就被屏蔽掉了。  
但是在严格模式下，eval有自己的词法作用域，也就意味着不能修改所在的作用域。  
setTimeout和setInterval第一个参数也可以是字符串，内容可以被解析为一段动态生成的代码。  
new Function(..)的行为也很类似，最后一个参数可以接受字符串，并将其转换成动态生成的函数。  
在webpack编译之后输出的文件里面其实就用到了eval，但是实际开发中还是不要动态生成代码，尽量不要用。会有性能损失。

### with
看过vue2源码的话，在生成render函数的时候，那个函数体里面就有这个。  
它通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。  
例如：
```
var obj = {
  a:1,
  b:2,
  c:3
}
//普通做法
obj.a=2
obj.b=3
obj.c=4
//with
with(obj){
  a=3;
  b=4;
  c=5;
}
```
副作用例子：
```
var obj1={
  a:3
}
var obj2={
  b:3
}
function foo(obj){
  with(obj){
    a=2
  }
}
foo(obj1)
console.log(obj1.a)//2
foo(obj2)
console.log(obj2.a)//undefind
console.log(a)//2
```
当是obj1的时候a=2找到了obj1.a，所以结果是2；但是obj2的里面是没有a的，没有找到，让后去上一级找也就是全局也没有，所以他就在全局创建了一个。  
虽然with可以将一个对象处理为词法作用域，但是这个块内部的var声明不会被限制在这个快的作用域中，而是被添加到with所在的函数作用域中。  
严格模式下with被禁止使用。  

## 性能
js引擎会在编译阶段进行数项性能优化。其中有些优化依赖于能够根据代码的词法进行静态的分析，并**预先确定所有变量和函数的定义位置**，才能在执行过程中快速的找到标识符。  
但是如果引擎在代码中发现了eval或with，他只能简单的假设关于标识符的判断都是无效的，因为无法在词法分析阶段明确知道会介绍到什么代码。  

**总结**：词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何进行查找。

# 函数作用域和块作用域
**函数作用域**指，属于这个函数的全部变量都可以在整个函数的范围内使用以及复用。

区分函数声明和表达式最简单的方法就是看function的位置：
- 如果function是声明中的第一个词，那么就是一个函数声明
- 否则就是函数表达式

**块级作用域**：可以理解成for  if这种代码块中的作用域，但不是完全意义上的块级作用域，因为里面声明的变量在外部能够访问，也就是说并不是在当前作用域内。
try/catch的catch分句会创建一个块级作用域，其中声明的变量仅在catch内部有效。  
es6中新增了``let``关键字，用来声明变量。它和``var``的区别在于，可以将作用域绑定在所在的``{...}``内。上面for和if的问题通过let就可以解决。  
es6中还新增了一个关键字``const``，也是块级作用域，但是声明的是常量。

# 提升
引擎在解释js代码之前，会先对其进行编译。编译阶段会找到所有的声明，定义声明它们，用合适的作用域关联起来。赋值相关操作会留在原地等待执行阶段。  
这个过程就好像声明被从原来的位置移动到了最上面，这个过程就叫做提升。  
现有声明，后有赋值。函数的声明一样。  
在这个过程中函数优先，也就是说函数会首先被提升，然后才是变量。  
函数声明有两种方式：
- 函数式即function为第一个关键词
  - 这种方式就包括了函数体
  - 也就是说可以在代码之前调用函数
- 声明式即function不是第一个关键词，例如声明变量接受
  - 这时提升的是指变量，函数表达式会在原地等待执行阶段。
  - 赋值之前调用会报错

提升是在同一作用域下，如果重名后面的赋值覆盖前面的。


# 作用域闭包
当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。
例如：
```
function foo(){
  var a = 1
  function bar(){
    console.log(a)
  }
  return bar
}
var baz = foo()
baz()//2
```
这就形成了一个闭包。  
函数bar()的词法作用域能够访问foo()的内部作用域，然后我们又将bar()函数本身当做返回值;  
函数foo()执行后，其返回值赋值给baz并且调用bar()，实际上只是通过不同的标识符引用调用了内部的函数bar();  
foo()执行后通常会期待foo()的整个内部作用域被销毁，因为引擎有垃圾回收机制，会释放不再使用的内存空间。  
但是bar()在使用，所以无法销毁。  
因为bar声明在foo()内部，bar()之后的调用需要能访问foo()的内部作用域。  
也就是bar()依然保持着对该作用域的引用，而这个引用就是闭包。

我之前在思否上面看到过一个问题，觉得很有代表性：
```
function foo(){
  var a= 2
  function bar(){
    console.log(a)
  }
  bar()
}
foo()
```
这是比闭包吗？

从前面的定义来说这个不是闭包，但是他基于词法作用域的查找规则，是闭包的一部分，非常重要的一部分。

这些代码都有些死板，只是为了解释如何使用闭包。
例如:
```
function wait(msg){
  setTimeout(function timer(){
    console.log(msg)
  },1000)
}
wait('hello,closure')
```
上面的代码讲一个内部的函数timer传递给了setTimeout，timer可以访问wait的词法作用域，保留着对msg的引用。  
内置的工具函数setTimeout保持着对第一个参数的引用，就是timer，引擎会调用这个函数，而词法作用域在这个过程中保持完整。这就是闭包。  
日常中的定时器、事件监听器、ajax请求、跨窗口通信、web workers等任务中，只要使用了回调函数，实际上就是在使用闭包。  
闭包也可以用于模块化。  
**es6中的模块机制**  
es6会将文件当做独立的模块来处理。每个模块可以导入其他模块或特定的API成员，同样的也可以导出自己的API成员。  
上面说到的基于闭包的函数式的模块并不是静态的，编译器无法识别，只有在运行时才知道里面有什么。  
而es6的这种属于静态的，在编译阶段会进行检查，例如某些api引用不存在，会在编译的时候就抛出错误。  
- import
  - 导入
- export
  - 导出

# 动态作用域
- 词法作用域在写代码或者说定义是确定的  
  - 作用域链基于代码中的作用于嵌套
- 而动态作用域是在运行时确定的
  - 不关心函数和作用域是如何声明的以及在何处
  - 只关心它们从何处调用的
  - 作用域链基于调用栈

# 块作用域的代替方案
在es6中已经原生支持了，但是如果要兼容es5就不能直接使用。  
前面提到过try/catch，其实就可以通过这个来实现：
```
try{
  throw 2
}catch(a){
  console.log(a)//2
}
consloe.log(a)//referenceError
```


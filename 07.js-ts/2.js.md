# 作用域
作用域是一套规则，用于确定在何处以及如何查找变量。即变量的可用范围，防止不同范围内的变量相互干扰。  
## js的作用域分为两种：
- 全局作用域
  - 不属于任何函数的外部范围
- 函数作用域
  - 保存在函数范围，包括形参
  - 函数作用域只有在函数执行的时候才会创建
    - this对象就在其中
    - 执行完毕会立即回收内存
    - 这是理解闭包的基础
- 关于块级作用域
  - js中不存在块级作用域
  - 只有函数的大括号才能产生局部作用域
  - let、const申明的方式并不能使所在大括号成为块级作用域
## 作用域链
js是词法作用域，就是由写代码时将变量和函数写在哪决定的。  
当一个块或者函数嵌套在另一个块或者函数中时，就会发生作用域嵌套。因此在当前作用域下查找某个变量时，引擎就会依次向外层查找，直到找到，或者到全局，这就是作用域链。
### 作用域闭包
当函数可以记住所在词法作用域时，即使是在当前词法作用域外执行，这时就产生了闭包。简单来说就是外层函数调用后，外层函数的作用域对象被返回的函数作用域引用着，无法释放，就形成了闭包。
### 欺骗词法
词法分析器在处理代码时会保持作用域不变，但是会有一些特殊的方法可以在词法分析器处理过后依然可以修改作用域。
#### eval
这个方法可以接受一个字符串参数，并且将其视为就是写在这个位置的代码。也就是说里面涉及到作用域的操作，引擎会默认在当前作用域查找操作。
#### with
通常当做重复引用一个对象中多个属性的快捷方式，可以不需要重复的引用对象本身。
## 赋值操作
变量的赋值操作分两步：
- 首先，如果变量在当前作用域集合中不存在，则声明变量，否则就跳过声明
  - 查找变量容器本身，操作的目标
- 然后在运行引擎会在作用域集合中查找该变量，如果能找就对其赋值。
  - 如果直接对未声明的变量赋值，会默认将该变量声明到全局
  - 如果直接对未声明的变量进行运算操作等，会报错。
- 函数并不符合变量操作
  - 函数式声明的函数，是在编译阶段代码生成的同时处理声明和值的定义
## 编译原理
- 分词/词法分析
  - 将我们写的代码分解成有意义的代码块--词法单元
- 解析/语法分析
  - 将上面得到的词法单元流数组，转换成一个代表了程序语法结构的树--抽象语法树AST
- 代码生成
  - 将AST转换成机器可以执行的指令
**js的编译过程不是发生在构建的时候，而是在代码执行前很短的时间内完成的。**
### 提升
引擎在解释代码之前，会对其先进行编译。编译阶段会找到所有的声明，定义声明它们，用合适的作用域关联起来。赋值操作留在原地，等待执行阶段。这个过程就叫做提升。  
先有声明，再有赋值。函数式声明也是一样。  
提升是在同一作用域下，如果重名后面的覆盖前面的。

# 原型

# this
this会自动定义在所有的函数作用域中，函数会自动引用合适的上下文对象，即当前函数的运行环境。
- this是在运行时绑定的，并不是在编写的时候，它的上下文取决与函数调用时的各种条件
- this既不指向函数自身，也不指向函数的词法作用域
- 当一个函数被调用的时候会创建一个执行上下文对象
  - 会包含函数在哪里调用，函数的调用方式，传入的参数等信息
  - this只是其中的一个属性，会在函数执行的时候用到
## 绑定规则
- 默认绑定
  - 函数的独立调用,this指向全局
  - 在严格模式下是undefined
- 隐式绑定
  - 被某个对象拥有包含，以某个对象.的形式调用，函数的this会绑定到这个对象上。
  - 如果是对象链式的调用，那么会绑定最后一个对象，即离调用函数最近的那个。
  - 隐式丢失
    - 如果不是直接调用而是赋值给一个变量再调用,此时变量只是一个引用，引用的是函数本身，因此变成了不带任何修饰的函数调用，成了默认绑定。
    - 以传参的形式也是一样的因为传参就是一种隐式的赋值
- 显示绑定
  - 就是在某个对象上强制调用函数
    - 使用函数的call和apply方法
      - 第一个参数是一个对象，给this准备的
      - apply第二个参数为数组，函数的参数
      - call第二个参数开始为函数的参数，用逗号间隔
    - 使用bind方法
      - 也可以叫做硬绑定
      - 返回一个新的函数
      - 其他参数和call一样
- new绑定
  - 用new来调用函数时
    - 创建或者说构建一个全新的对象
    - 这个新的对象会被执行原型连接
    - 这个对象会被绑定到函数调用的this
    - 如果函数没有返回其他对象，那么new表达式的函数会自动返回这个新对象
- 优先级
  - 函数是否在new中调用
    - 是的话this就是新创建的对象
  - 函数通过显示绑定
    - 是的话this就是绑定的对象
  - 函数是否在某个上下文对象中调用
    - 是的话this就是这个对象
  - 如果都不是，就使用默认绑定
    - 严格模式为undefined
    - 否则就是全局对象
**如果使用null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候会被忽略，实际会使用默认的规则。**  
**上面的规则不适用于箭头函数，箭头函数是根据外层外层作用于来决定this的，会继承外层函数调用的this绑定。**
# 类

# 对象
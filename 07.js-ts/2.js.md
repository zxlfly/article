# 作用域
作用域是一套规则，用于确定在何处以及如何查找变量。即变量的可用范围，防止不同范围内的变量相互干扰。  
## js的作用域分为两种：
- 全局作用域
  - 不属于任何函数的外部范围
- 函数作用域
  - 保存在函数范围，包括形参
  - 函数作用域只有在函数执行的时候才会创建
    - this对象就在其中
    - 执行完毕会立即回收内存
    - 这是理解闭包的基础
- 关于块级作用域
  - js中不存在块级作用域
  - 只有函数的大括号才能产生局部作用域
  - let、const申明的方式并不能使所在大括号成为块级作用域
## 作用域链
js是词法作用域，就是由写代码时将变量和函数写在哪决定的。  
当一个块或者函数嵌套在另一个块或者函数中时，就会发生作用域嵌套。因此在当前作用域下查找某个变量时，引擎就会依次向外层查找，直到找到，或者到全局，这就是作用域链。
### 作用域闭包
当函数可以记住所在词法作用域时，即使是在当前词法作用域外执行，这时就产生了闭包。简单来说就是外层函数调用后，外层函数的作用域对象被返回的函数作用域引用着，无法释放，就形成了闭包。
### 欺骗词法
词法分析器在处理代码时会保持作用域不变，但是会有一些特殊的方法可以在词法分析器处理过后依然可以修改作用域。
#### eval
这个方法可以接受一个字符串参数，并且将其视为就是写在这个位置的代码。也就是说里面涉及到作用域的操作，引擎会默认在当前作用域查找操作。
#### with
通常当做重复引用一个对象中多个属性的快捷方式，可以不需要重复的引用对象本身。
## 赋值操作
变量的赋值操作分两步：
- 首先，如果变量在当前作用域集合中不存在，则声明变量，否则就跳过声明
  - 查找变量容器本身，操作的目标
- 然后在运行引擎会在作用域集合中查找该变量，如果能找就对其赋值。
  - 如果直接对未声明的变量赋值，会默认将该变量声明到全局
  - 如果直接对未声明的变量进行运算操作等，会报错。
- 函数并不符合变量操作
  - 函数式声明的函数，是在编译阶段代码生成的同时处理声明和值的定义
## 编译原理
- 分词/词法分析
  - 将我们写的代码分解成有意义的代码块--词法单元
- 解析/语法分析
  - 将上面得到的词法单元流数组，转换成一个代表了程序语法结构的树--抽象语法树AST
- 代码生成
  - 将AST转换成机器可以执行的指令
**js的编译过程不是发生在构建的时候，而是在代码执行前很短的时间内完成的。**
### 提升
引擎在解释代码之前，会对其先进行编译。编译阶段会找到所有的声明，定义声明它们，用合适的作用域关联起来。赋值操作留在原地，等待执行阶段。这个过程就叫做提升。  
先有声明，再有赋值。函数式声明也是一样。  
提升是在同一作用域下，如果重名后面的覆盖前面的。  
在这个过程中函数优先，也就是说函数会首先被提升，然后才是变量。

# 原型[[prototype]]
js中对象有一个特殊的[[prototype]]内置属性，其实就是对其他对象的引用。几乎所有对象在被创建时[[prototype]]都会被赋值一个非空值。Object.create就会创建一个拥有空原型链的对象。  
所有普通的[[prototype]]链最终都会指向Object.prototype  
**prototype机制就是存在于对象中的一个内部链接，会引用其他对象。作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在prototype链关联的对象上进行查找，以此类推，这就是原型链。**
## __proto__和constructor属性是对象独有的，prototype属性是函数独有的。函数本身也是对象！
- prototype对于函数而言就是保存共有成员
- constructor对于对象来说就是指向构造函数
- __proto__属性指向了内部的[[prototype]]对象，对于对象来说就是操作原型的
- 原型链就是由多级父对象继承形成的链式结构
### prototype
**函数在创建的时候，会默认创建该函数的prototype，这个prototype会有一个constructor属性默认指向这个函数。**
- 只是一个属性，默认指向原型对象，可以修改
- prototype的.constructor属性只是在函数声明时的默认属性，如果修改了prototype属性，默认的.constructor就没了，不会自动关联
### _proto__
这个属性在es6之前并不在标准中，作为Object.prototype上的一个存储器，主要用来设置或者获取某个对象的[[prototype]]
## 属性设置和屏蔽
对对象普通属性访问赋值时，如果存在可以直接赋值。如果不存在就会去原型链上面查找。
- 如果原型链上存在，且没有设置只读，那么会在该对象上添加该属性，后续就访问不到原型链上面的属性了
- 如果原型链上存在，且被标记为只读，那么无法修改，且不会在该对象上创建属性
  - 如果是严格模式会报错，否则会忽略
- 如果原型链上存在，且是一个setter，那么一定会调用这个setter。并且不会在该对象上创建属性，也不会修改setter
# this
this会自动定义在所有的函数作用域中，函数会自动引用合适的上下文对象，即当前函数的运行环境。
- this是在运行时绑定的，并不是在编写的时候，它的上下文取决与函数调用时的各种条件
- this既不指向函数自身，也不指向函数的词法作用域
- 当一个函数被调用的时候会创建一个执行上下文对象
  - 会包含函数在哪里调用，函数的调用方式，传入的参数等信息
  - this只是其中的一个属性，会在函数执行的时候用到
## 绑定规则
- 默认绑定
  - 函数的独立调用,this指向全局
  - 在严格模式下是undefined
- 隐式绑定
  - 被某个对象拥有包含，以某个对象.的形式调用，函数的this会绑定到这个对象上。
  - 如果是对象链式的调用，那么会绑定最后一个对象，即离调用函数最近的那个。
  - 隐式丢失
    - 如果不是直接调用而是赋值给一个变量再调用,此时变量只是一个引用，引用的是函数本身，因此变成了不带任何修饰的函数调用，成了默认绑定。
    - 以传参的形式也是一样的因为传参就是一种隐式的赋值
- 显示绑定
  - 就是在某个对象上强制调用函数
    - 使用函数的call和apply方法
      - 第一个参数是一个对象，给this准备的
      - apply第二个参数为数组，函数的参数
      - call第二个参数开始为函数的参数，用逗号间隔
    - 使用bind方法
      - 也可以叫做硬绑定
      - 返回一个新的函数
      - 其他参数和call一样
- new绑定
  - 用new来调用函数时
    - 创建或者说构建一个全新的对象
    - 这个新的对象会被执行原型连接
      - 设置新对象的__proto__继承构造函数的原型对象prototype
      - 用当前对象调用构造函数，添加属性和方法
    - 这个对象会被绑定到函数调用的this
    - 如果函数没有返回其他对象，那么new表达式的函数会自动返回这个新对象
- 优先级
  - 函数是否在new中调用
    - 是的话this就是新创建的对象
  - 函数通过显示绑定
    - 是的话this就是绑定的对象
  - 函数是否在某个上下文对象中调用
    - 是的话this就是这个对象
  - 如果都不是，就使用默认绑定
    - 严格模式为undefined
    - 否则就是全局对象
**如果使用null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候会被忽略，实际会使用默认的规则。**  
**上面的规则不适用于箭头函数，箭头函数是根据外层作用域来决定this的，会继承外层函数调用的this绑定。内部的this就是定义时上层作用域中的this。**  
**可以简单的理解为静态的，如果将箭头函数直接赋值对象的属性，然后调用this是不能指向对象，因为对象不构成单独的作用域。而普通函数的this为动态的，和函数的运行环境相关。**
# 类
es6中class除了语法更好看之外

- 不在引用扎乱的prototype
- 不需要手动的使用Object.create来替换prototype，也不需要设置**proto**或者Object.setPrototypeOf
- 可以使用super来实现相对多态
- 可以使用extends很自然的扩展对象
- 类的声明不会提升
- 默认处于严格模式

**类的属性和方法，除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）**  
```
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
```
**现在新的写法可以直接将实例属性写在class内部，不使用this也可以**  
```
class foo {
  bar = 'hello';
  baz = 'world';

  constructor() {
    // ...
  }
}
```
## 公有 可以被修改

- 公有实例方法 
   - 可以在类的实例中调用，this指向实例本身，可以使用super访问超类
- 公有实例字段 
   - 存在于每个类的实例中
## static 可以被修改
**父类的静态属性和静态方法，会被子类继承。直接通过类来调用。**

- 静态方法 
   - 该方法不会被实例继承，而是直接通过类来调用
   - 如果静态方法包含this关键字，这个this指的是类，而不是实例
- 静态属性 
   - 不会被实例继承，而是直接通过类来调用
## 私有
**私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。**
**实例对象也不能直接访问，可以通过其他方法间接访问。**

- 私有方法 
   - 通过`#name(){}`句型声明	
   - 静态的私有方法，只能在类里调用
   - 可以通过公有方法访问
- 私有字段 
   - 通过`#name`句型声明
   - 不能在class外访问，只能在class内部访问，静态私有也一样
   - 实例对象也不能直接访问
      - 可以通过get方法间接访问
## 继承

- 在内部使用call方法 
   - 可以继承构造函数的方法和属性，但是不能继承原型链上面的
- 直接将prototype指向需要继承的类实例 
   - 可以解决上面你的问题，但是不能给父类传参
- 结合上面两种方法就可以解决这些问题 
   -  
```
function Person(name,age){
    this.name=name
    this.age=age
    this.run=function(){
        alert(this.name+'睡觉')
    }
}
Person.prototype.sex="men"
Person.prototype.work=function(){
    alert(this.name+'work')
}
var p=new Person('李四',20);
p.run();

function child3(name,age){
    Person.call(this,name,age)
}
child3.prototype=new Person()
var w3 = new child3('lao6',22)
w3.run()
w3.work()
```
 

- extends关键字 
   - class可以直接通过extends关键字实现继承
   - es6规定子类必须在constructor中调用super() 
      - 因为子类this对象需要通过父类构造函数塑造，得到父类实例同样的属性和方法，然后再加工添加子类自己的属性和方法
   - **父类除了私有的属性和方法，其他的都会被子类继承**

#### super
ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。
ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用super()方法，因为这一步会生成一个继承父类的this对象，没有这一步就无法继承父类。
super和this不一样，不是动态绑定的，他会在静态声明的时候绑定
super作为函数调用时，代表父类的构造函数。
super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

## 静态块
允许在类的内部设置一个代码块，在类生成时运行且只运行一次，主要作用是对静态属性进行初始化。以后，新建类的实例时，这个块就不运行了。
静态块内部可以使用类名或this，指代当前类，不能有return语句。
除了静态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。
```markdown
let getX;

export class C {
  #x = 1;
  static {
    getX = obj => obj.#x;
  }
}

console.log(getX(new C())); // 1
```

## new.target 属性
可以用来确定构造函数是怎么调用的。

# 对象
js中对象定义有字面形式和构造形式。  
for...in语句可以用来遍历可枚举的属性，包括原型链  
for...of遍历可迭代对象定义要迭代的数据